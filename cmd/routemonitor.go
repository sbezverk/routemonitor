package main

import (
	"flag"
	"fmt"
	"net"
	"os"
	"os/signal"
	"time"

	"net/http"
	_ "net/http/pprof"

	"github.com/golang/glog"
	"github.com/sbezverk/routemonitor/pkg/bmplistener"
	"github.com/sbezverk/routemonitor/pkg/classifier"
	"github.com/sbezverk/routemonitor/pkg/server"
)

var (
	srcPort  int
	perfPort int
)

func init() {
	flag.IntVar(&srcPort, "source-port", 5000, "port exposed to outside")
	flag.IntVar(&perfPort, "performance-port", 56767, "port used for performance debugging")
}

var (
	onlyOneSignalHandler = make(chan struct{})
	shutdownSignals      = []os.Signal{os.Interrupt}
)

func setupSignalHandler() (stopCh <-chan struct{}) {
	close(onlyOneSignalHandler) // panics when called twice

	stop := make(chan struct{})
	c := make(chan os.Signal, 2)
	signal.Notify(c, shutdownSignals...)
	go func() {
		<-c
		close(stop)
		<-c
		os.Exit(1) // second signal. Exit directly.
	}()

	return stop
}

func main() {
	flag.Parse()
	_ = flag.Set("logtostderr", "true")
	// Initializing Kafka publisher
	// other publishers sutisfying pub.Publisher interface can be used.
	go func() {
		glog.Info(http.ListenAndServe(fmt.Sprintf(":%d", perfPort), nil))
	}()
	c := classifier.NewClassifierNLRI()
	l, err := bmplistener.NewBMPListener(srcPort, c)
	if err != nil {
		glog.Errorf("failed to start listener with error: %+v", err)
		os.Exit(1)
	}
	l.Start()
	// Initialize gRPC server
	conn, err := net.Listen("tcp", ":55000")
	if err != nil {
		glog.Errorf("failed to setup listener with with error: %+v", err)
		os.Exit(1)
	}
	srv := server.NewRouteMonitor(conn, c)
	srv.Start()
	stopCh := setupSignalHandler()
	// go fakeBMPGenerator(c, stopCh)
	<-stopCh
	srv.Stop()
	l.Stop()
	os.Exit(0)
}

func fakeBMPGenerator(c classifier.NLRI, stopCh <-chan struct{}) {
	ticker := time.NewTicker(time.Second * 10)
	msgs := []struct {
		name       string
		bmpMessage []byte
		routeType  classifier.RouteType
		ipv6       bool
	}{
		{
			name:       "vpnv4_1",
			bmpMessage: []byte{0x03, 0x00, 0x00, 0x00, 0xc6, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x92, 0x01, 0x68, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x13, 0xce, 0xc0, 0xa8, 0x05, 0x04, 0x5e, 0xf1, 0x2c, 0x59, 0x00, 0x0e, 0x79, 0xb6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x96, 0x02, 0x00, 0x00, 0x00, 0x7f, 0x90, 0x0e, 0x00, 0x2d, 0x00, 0x01, 0x80, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x92, 0x01, 0x68, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x78, 0x00, 0x43, 0x00, 0x00, 0x00, 0x13, 0xce, 0x00, 0x00, 0xfe, 0x0a, 0xc0, 0xa8, 0x05, 0x02, 0x40, 0x01, 0x01, 0x02, 0x40, 0x02, 0x06, 0x02, 0x01, 0x00, 0x00, 0xfd, 0xeb, 0x80, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x04, 0x00, 0x00, 0x00, 0x64, 0xc0, 0x10, 0x08, 0x00, 0x02, 0x00, 0x05, 0x00, 0x00, 0xfd, 0xeb, 0xc0, 0x28, 0x25, 0x05, 0x00, 0x22, 0x00, 0x01, 0x00, 0x1e, 0x00, 0x20, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x01, 0x00, 0x06, 0x28, 0x18, 0x10, 0x00, 0x10, 0x40},
			routeType:  classifier.VPNv4,
			ipv6:       false,
		},
		{
			name:       "ipnv4_1",
			bmpMessage: []byte{0x03, 0x00, 0x00, 0x00, 0x67, 0x00, 0x01, 0x00, 0x00, 0x00, 0x13, 0xce, 0x00, 0x00, 0xfe, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x0d, 0x0d, 0x02, 0x00, 0x00, 0xfd, 0xeb, 0xc0, 0xa8, 0x05, 0x01, 0x5e, 0xf1, 0x2c, 0x59, 0x00, 0x0e, 0x85, 0x30, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x37, 0x02, 0x00, 0x00, 0x00, 0x1b, 0x40, 0x01, 0x01, 0x02, 0x40, 0x02, 0x06, 0x02, 0x01, 0x00, 0x00, 0xfd, 0xeb, 0x40, 0x03, 0x04, 0x0d, 0x0d, 0x0d, 0x02, 0x80, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x20, 0xc0, 0xa8, 0x05, 0x01},
			routeType:  classifier.UnicastIPv4,
			ipv6:       false,
		},
		{
			name:       "ipv4_2",
			bmpMessage: []byte{0x03, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x01, 0x00, 0x00, 0x13, 0xce, 0xc0, 0xa8, 0x05, 0x04, 0x5e, 0xf1, 0x2c, 0x5e, 0x00, 0x06, 0xf5, 0x8b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x37, 0x02, 0x00, 0x00, 0x00, 0x1b, 0x40, 0x01, 0x01, 0x02, 0x40, 0x02, 0x06, 0x02, 0x01, 0x00, 0x00, 0x13, 0xce, 0x40, 0x03, 0x04, 0x18, 0x18, 0x18, 0x01, 0x80, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x18, 0x18, 0x18, 0x00},
			routeType:  classifier.UnicastIPv4,
			ipv6:       false,
		},
	}
	conn, err := net.Dial("tcp", fmt.Sprintf(":%d", srcPort))
	if err != nil {
		glog.Errorf("failed to start bmp generator with error: %+v", err)
		os.Exit(1)
	}
	i := 0
	for {
		if _, err := conn.Write(msgs[i].bmpMessage); err != nil {
			if err != nil {
				glog.Errorf("failed to send bmp message with error: %+v", err)
				os.Exit(1)
			}
		}
		select {
		case <-ticker.C:
			all := c.GetAll(msgs[i].routeType)
			glog.Infof("All routes of type %+v: %+v", msgs[i].routeType, all)
			for _, r := range all {
				p, m, _ := net.ParseCIDR(r)
				l, _ := m.Mask.Size()
				var a []byte
				if msgs[i].ipv6 {
					a = net.IP(p).To16()
				} else {
					a = net.IP(p).To4()
				}
				if !c.Check(msgs[i].routeType, a, l) {
					glog.Errorf("Check for existing prefix failed")
				} else {
					glog.Infof("Check for existing prefix succeeded")
				}
			}
			glog.Infof("All routes of type %+v: %+v", msgs[i].routeType, c.GetAll(msgs[i].routeType))
			i++
			if i >= len(msgs) {
				i = 0
			}
			continue
		case <-stopCh:
			return
		}
	}
}
